# Распознавание изображений цифр банковской карты

+ [Реализация сбора данных](#Parag-1)
+ [Реализация модели распознавания символов](#Parag-2)

## <a name="Parag-1"></a> Реализация сбора данных
##### (датасет изображений загружен в виде zip-архива)
Этапом, который предшествует созданию модели, является этап сбора и
подготовки данных. В рамках данной работы для обучения модели
распознавания символов необходима выборка, состоящая из изображений
следующих групп символов:
+ буквы латинского алфавита;
+ цифры от 0 до 9;
+ специальные знаки, которые могут встречаться в поле имени
держателя карты, а именно – дефис («–»), точка («.»).

Каждый отдельный символ в группе представляет собой класс этого
символа. Таким образом, выборка должна содержать изображения 38 различных классов, среди которых впоследствии модель будет проводить
распределение подаваемых ей на вход символов.
Важным уточнением является то, что символы, располагаемые на
банковских картах, могут быть как напечатаны, так и эмбоссированы
(выдавлены). Также целевой шрифт OCR-B банковской карты,
регламентированный стандартом, крайне отличается от тех, что обычно
используются в печатной промышленности. Поэтому для подобной задачи не
подходит стандартная выборка изображений букв и цифр, так как это может
привести к некорректному результату.

Готовый набор данных для цифр взят из открытого источника на портале
«Kaggle». В нем содержится 885 изображений, однако распределение
таких изображений между классами неравномерное. Так для одного символа
данных может быть значительно больше, чем для другого. Поэтому
потребовалось посредством аугментации данных сравнять количество
изображений до 500 штук для каждого класса.

Для генерации новых данных исходные изображения приводятся к
единому размеру 40 на 60 пикселей. Опытным путем установлено, что именно
такой размер изображения не замедляет процесс обучения и содержит
достаточное количество информации о символе, и при этом не влияет на
точность распознавания. Затем для каждого класса символов применяется
процедура наложения искажений, которая заключается в выполнении
следующих действий:
+ выбирается случайное изображение;
+ применяется к нему афинного преобразования с помощью матрицы
вращения для поворота изображения вокруг заданного центра вращения.
Матрица задаётся по следующей формуле:

<img src="https://sun9-76.userapi.com/impf/2eWLfv4Q6I3IXqfWKYf_6qIBxAa4WiP7M4SVIw/NC0zPWPDUJY.jpg?size=820x214&quality=96&proxy=1&sign=d34020a0bd7af2ee2873000e2eef7c56" width="370" height="107" />

> где center.x – координата центра вращения на исходном изображении по оси
Χ; center.y – координата центра вращения на исходном изображении по оси
Υ; scale – масштаб; angle – угол поворота в градусах.

+ накладывается шум типа «соль и перец», который представляет собой
добавление на изображение черных и белых пикселей в случайном порядке.
Для того, чтобы накладываемые искажения не повторяли друг друга и
не создавали одинакового эффекта, применяемого к изображениям, все
передаваемые параметры настройки задаются случайным образом в заданном
диапазоне. Такое решение гарантирует создание более разнообразной
выборки.

Затем все изображения необходимо нормализовать и привести значения
пикселей в диапазон от 0 до 1. Для этого необходимо каждый пиксель
изображения разделить на 255.

В итоге получилась обучающая выборка, объемом в 3500 изображений,
и тестовая, состоящая из 1500 изображений. На рисунке 7 представлен пример
пятидесяти таких изображений. 


## <a name="Parag-2"></a> Реализация модели распознавания символов
В данной работе для распознавания символов была разработана
свёрточная нейронная сеть, состоящая из 6 слоев.
Входной слой состоит из 3-х карт признаков, которые соответствуют
трем цветовым каналам распознаваемого изображения, и содержит 60 * 40 * 3
= 7200 нейронов, где первые два параметра складываются из размерности
изображения. Данный слой служит для передачи нейронной сети входной
информации.

Следующий слой является первым скрытым свёрточным слоем. Он
извлекает элементы, которые могут содержать в себе информацию, важную
для дальнейшей классификации, из исходного изображения путем его
«сканирования» с помощью фильтра 3 × 3 пикселей. Для каждой такой области
пикселей в изображении операция свертки вычисляет скалярное произведение
значений пикселей изображения и весов, определенных в фильтре. По мере
обучения модели значения весов будут изменяться.
Далее следуют ещё два скрытых свёрточных слоя с фильтрами
размерностью 5 × 5 и 7 × 7 пикселей соответственно.

В качестве функции активации для свёрточных слоев эмпирическим
путем была выбрана функция ReLU. Выбор осуществлялся на основании
достижения необходимого уровня ошибки в процессе обучения. Процентная
величина, отражающая расхождение между ожидаемым и полученным
ответами, полученная в результате использования данной функции, была
значительно ниже по сравнению со значениями других функций.

Следующим слоем является слой выравнивания. Он преобразует
двумерный массив признаков в одномерный, не имеет параметров для
обучения, служит для переформатирования данных и передаёт их на вход
следующему полносвязному слою – слою пулинга. Он, в свою очередь,
уплотняет карту признаков до числа, равного количеству классов. Для
выходного слоя используется функция активации Softmax.
Таким образом, для каждого распознаваемого изображения символа на
выходе получаем массив псевдовероятностных оценок нахождения данного
символа на данном изображении

Для контроля скорости обучения на этапе компиляции модели в качестве
оптимизатора был выбран стохастический градиентный спуск (SGD) с
категориальной кросс-энтропией как функцией потери. Для обучения сети
использовался алгоритм обратного распространения ошибки. В качестве
оценки точности распознавания при валидации значений использовалась
метрика «accuracy».

Ответ модели машинного обучения представляет собой массив из 38
значений – по количеству классов, на которые была разбита обучающая
выборка. Каждое значение лежит в интервале от 0 до 1 и характеризует
уверенность модели в том, что переданное на вход изображение принадлежит
тому или иному классу.

Потому при обработке результата предсказания от модели машинного
обучения необходимо пройтись по всему вектору, возвращаемому моделью, и
найти индекс элемента с максимальным значением. Искомый индекс будет
соответствовать порядковому номеру того класса, который был определен при
обучении модели и которому соответствует символ, предсказанный моделью.
